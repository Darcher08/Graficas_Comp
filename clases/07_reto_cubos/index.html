<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebGL Cubo 3D - Explicaci√≥n</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            border-radius: 5px;
        }
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            overflow-x: auto;
        }
        .highlight {
            background: #ffeaa7;
            padding: 2px 5px;
            border-radius: 3px;
        }
        canvas {
            border: 2px solid #333;
            display: block;
            margin: 20px auto;
        }
        .step {
            counter-increment: step-counter;
            margin: 20px 0;
        }
        .step::before {
            content: "Paso " counter(step-counter) ": ";
            font-weight: bold;
            color: #007bff;
        }
        body {
            counter-reset: step-counter;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .explanation {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé≤ WebGL Cubo 3D - Explicaci√≥n Completa</h1>
        
        <div class="section">
            <h2>¬øQu√© hace este c√≥digo?</h2>
            <p>Este c√≥digo crea un <span class="highlight">cubo 3D que rota</span> en el navegador usando WebGL. Es como construir un cubo de Lego digital que gira continuamente.</p>
        </div>

        <canvas id="my_Canvas" width="400" height="400"></canvas>

        <div class="step">
            <h3>Preparar el lienzo (Canvas)</h3>
            <div class="code-block">
var canvas = document.getElementById("my_Canvas");
gl = canvas.getContext("experimental-webgl");
            </div>
            <div class="explanation">
                <strong>¬øQu√© hace?</strong> Es como preparar un lienzo para pintar, pero en 3D. WebGL es como un pincel s√∫per avanzado que puede dibujar en 3 dimensiones.
            </div>
        </div>

        <div class="step">
            <h3>Definir la forma del cubo</h3>
            <div class="grid">
                <div>
                    <h4>V√©rtices (esquinas del cubo)</h4>
                    <div class="code-block">
var vertices = [
  -1,-1,-1,  1,-1,-1,  1, 1,-1, -1, 1,-1,
  -1,-1, 1,  1,-1, 1,  1, 1, 1, -1, 1, 1
];
                    </div>
                    <div class="explanation">
                        Un cubo tiene 8 esquinas. Cada esquina tiene 3 n√∫meros: X, Y, Z (como una direcci√≥n en el espacio).
                    </div>
                </div>
                
                <div>
                    <h4>Colores</h4>
                    <div class="code-block">
var colors = [
  5,3,7, 5,3,7, 5,3,7, 5,3,7,
  1,1,3, 1,1,3, 1,1,3, 1,1,3,
  // ... m√°s colores
];
                    </div>
                    <div class="explanation">
                        Cada cara del cubo tiene un color diferente. Los n√∫meros representan intensidades de rojo, verde y azul.
                    </div>
                </div>
            </div>
        </div>

        <div class="step">
            <h3>Conectar los puntos (√çndices)</h3>
            <div class="code-block">
var indices = [
  0,1,2,  0,2,3,    // cara frontal
  4,5,6,  4,6,7,    // cara trasera
  // ... m√°s conexiones
];
            </div>
            <div class="explanation">
                <strong>¬øPor qu√© esto?</strong> Es como conectar los puntos con l√≠neas. Cada grupo de 3 n√∫meros forma un tri√°ngulo. Dos tri√°ngulos = una cara del cubo.
            </div>
        </div>

        <div class="step">
            <h3>Shaders (los "pintores" m√°gicos)</h3>
            <div class="grid">
                <div>
                    <h4>Vertex Shader</h4>
                    <div class="code-block">
"attribute vec3 position;" +
"uniform mat4 Pmatrix;" +
"void main(void) { " +
"gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);" +
"}"
                    </div>
                    <div class="explanation">
                        Toma cada punto del cubo y lo coloca en el lugar correcto en la pantalla, aplicando rotaci√≥n, zoom, etc.
                    </div>
                </div>
                
                <div>
                    <h4>Fragment Shader</h4>
                    <div class="code-block">
"varying vec3 vColor;" +
"void main(void) {" +
"gl_FragColor = vec4(vColor, 1.);" +
"}"
                    </div>
                    <div class="explanation">
                        Pinta cada peque√±o punto (pixel) del cubo con el color correcto.
                    </div>
                </div>
            </div>
        </div>

        <div class="step">
            <h3>Matrices (las transformaciones m√°gicas)</h3>
            <div class="code-block">
var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);
var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            </div>
            <div class="explanation">
                <ul>
                    <li><strong>proj_matrix:</strong> Como una c√°mara - decide c√≥mo se ve la perspectiva 3D</li>
                    <li><strong>mov_matrix:</strong> Controla rotaci√≥n y movimiento del cubo</li>
                    <li><strong>view_matrix:</strong> D√≥nde est√° situada la c√°mara (aqu√≠, alejada 6 unidades)</li>
                </ul>
            </div>
        </div>

        <div class="step">
            <h3>Animaci√≥n (hacer que rote)</h3>
            <div class="code-block">
var animate = function(time) {
    var dt = time - time_old;
    rotateZ(mov_matrix, dt * 0.005);
    rotateY(mov_matrix, dt * 0.002);
    rotateX(mov_matrix, dt * 0.003);
    // ... dibujar cubo
    window.requestAnimationFrame(animate);
};
            </div>
            <div class="explanation">
                Es como un flipbook. Cada frame (imagen), rota el cubo un poquito m√°s en X, Y y Z. Al repetir esto muy r√°pido, parece que est√° rotando suavemente.
            </div>
        </div>

        <div class="section">
            <h2>üîß Analog√≠a Simple</h2>
            <p>Imagina que est√°s haciendo una pel√≠cula de stop-motion de un cubo de Rubik:</p>
            <ol>
                <li><strong>V√©rtices:</strong> Las esquinas del cubo</li>
                <li><strong>√çndices:</strong> C√≥mo conectar las esquinas para formar caras</li>
                <li><strong>Colores:</strong> Pintar cada cara de diferente color</li>
                <li><strong>Shaders:</strong> Los "efectos especiales" que hacen que se vea 3D</li>
                <li><strong>Matrices:</strong> La posici√≥n de la c√°mara y c√≥mo rotar el cubo</li>
                <li><strong>Animate:</strong> Tomar 60 fotos por segundo, rotando un poco cada vez</li>
            </ol>
        </div>

        <div class="section">
            <h2>üí° Conceptos Clave para Recordar</h2>
            <div class="explanation">
                <p><strong>WebGL es como un chef muy espec√≠fico:</strong> Necesitas darle exactamente los ingredientes correctos (v√©rtices, colores, shaders) en el orden correcto, o no funcionar√°.</p>
                <p><strong>Todo son tri√°ngulos:</strong> WebGL solo entiende tri√°ngulos. Un cubo = 12 tri√°ngulos (2 por cada cara).</p>
                <p><strong>Las matrices son traductores:</strong> Convierten coordenadas 3D en posiciones 2D en tu pantalla.</p>
            </div>
        </div>
    </div>

    <script>
        // El mismo c√≥digo que proporcionaste, pero con comentarios explicativos
        var canvas = document.getElementById("my_Canvas");
        var gl = canvas.getContext("experimental-webgl");

        // V√©rtices: 8 esquinas del cubo (x,y,z para cada una)
        var vertices = [
            -1,-1,-1,  1,-1,-1,  1, 1,-1, -1, 1,-1,  // cara frontal
            -1,-1, 1,  1,-1, 1,  1, 1, 1, -1, 1, 1,  // cara trasera
            -1,-1,-1, -1, 1,-1, -1, 1, 1, -1,-1, 1,  // cara izquierda
             1,-1,-1,  1, 1,-1,  1, 1, 1,  1,-1, 1,  // cara derecha
            -1,-1,-1, -1,-1, 1,  1,-1, 1,  1,-1,-1,  // cara inferior
            -1, 1,-1, -1, 1, 1,  1, 1, 1,  1, 1,-1   // cara superior
        ];

        // Colores para cada cara (valores RGB normalizados)
        var colors = [
            5,3,7, 5,3,7, 5,3,7, 5,3,7,  // morado para cara frontal
            1,1,3, 1,1,3, 1,1,3, 1,1,3,  // amarillo para cara trasera
            0,0,1, 0,0,1, 0,0,1, 0,0,1,  // azul para cara izquierda
            1,0,0, 1,0,0, 1,0,0, 1,0,0,  // rojo para cara derecha
            1,1,0, 1,1,0, 1,1,0, 1,1,0,  // amarillo para cara inferior
            0,1,0, 0,1,0, 0,1,0, 0,1,0   // verde para cara superior
        ];

        // √çndices: c√≥mo conectar los v√©rtices para formar tri√°ngulos
        var indices = [
            0,1,2,   0,2,3,    // cara frontal (2 tri√°ngulos)
            4,5,6,   4,6,7,    // cara trasera
            8,9,10,  8,10,11,  // cara izquierda
            12,13,14, 12,14,15, // cara derecha
            16,17,18, 16,18,19, // cara inferior
            20,21,22, 20,22,23  // cara superior
        ];

        // Crear buffers (contenedores de datos para la GPU)
        var vertex_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        var color_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

        var index_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Shaders: programas que corren en la GPU
        var vertCode = 
            "attribute vec3 position;" +
            "uniform mat4 Pmatrix;" +
            "uniform mat4 Vmatrix;" +
            "uniform mat4 Mmatrix;" +
            "attribute vec3 color;" +
            "varying vec3 vColor;" +
            "void main(void) { " +
                "gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);" +
                "vColor = color;" +
            "}";

        var fragCode = 
            "precision mediump float;" +
            "varying vec3 vColor;" +
            "void main(void) {" +
                "gl_FragColor = vec4(vColor, 1.);" +
            "}";

        // Compilar shaders
        var vertShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertShader, vertCode);
        gl.compileShader(vertShader);

        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragShader, fragCode);
        gl.compileShader(fragShader);

        // Crear programa de shaders
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertShader);
        gl.attachShader(shaderProgram, fragShader);
        gl.linkProgram(shaderProgram);

        // Conectar atributos
        var Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
        var Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
        var Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");

        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
        var position = gl.getAttribLocation(shaderProgram, "position");
        gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(position);

        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
        var color = gl.getAttribLocation(shaderProgram, "color");
        gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(color);
        
        gl.useProgram(shaderProgram);

        // Matriz de proyecci√≥n (c√≥mo se ve la perspectiva)
        function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5*Math.PI)/180);
            return [
                0.5/ang, 0 , 0, 0,
                0, 0.5*a/ang, 0, 0,
                0, 0, -(zMax+zMin)/(zMax-zMin), -1,
                0, 0, (-2*zMax*zMin)/(zMax-zMin), 0
            ];
        }

        var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);
        var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
        var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];

        view_matrix[14] = view_matrix[14] - 6; // Alejar la c√°mara

        // Funciones de rotaci√≥n
        function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];

            m[1]=c*m[1]+s*mv0;
            m[5]=c*m[5]+s*mv4;
            m[9]=c*m[9]+s*mv8;
        }

        function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv1 = m[1], mv5 = m[5], mv9 = m[9];

            m[1] = m[1]*c-m[2]*s;
            m[5] = m[5]*c-m[6]*s;
            m[9] = m[9]*c-m[10]*s;

            m[2] = m[2]*c+mv1*s;
            m[6] = m[6]*c+mv5*s;
            m[10] = m[10]*c+mv9*s;
        }

        function rotateY(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]+s*m[2];
            m[4] = c*m[4]+s*m[6];
            m[8] = c*m[8]+s*m[10];

            m[2] = c*m[2]-s*mv0;
            m[6] = c*m[6]-s*mv4;
            m[10] = c*m[10]-s*mv8;
        }

        // Loop de animaci√≥n
        var time_old = 0;
        var animate = function(time) {
            var dt = time-time_old;
            
            // Rotar el cubo en los 3 ejes
            rotateZ(mov_matrix, dt*0.005);
            rotateY(mov_matrix, dt*0.002);
            rotateX(mov_matrix, dt*0.003);
            
            time_old = time;

            // Preparar para dibujar
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clearDepth(1.0);

            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Enviar matrices a los shaders
            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);
            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);
            
            // Dibujar el cubo
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            

            // Repetir en el pr√≥ximo frame
            window.requestAnimationFrame(animate);
        };
        animate(0);
    </script>
</body>
</html>